# Системный администратор раз в неделю создаёт архив пользовательских файлов.
# Однако объём диска, куда он помещает архив, может быть меньше, чем суммарный объём архивируемых файлов.
# Известно, какой объём занимает файл каждого пользователя.
# По заданной информации об объёме файлов пользователей и свободном объёме на архивном диске определите максимальное число пользователей,
# чьи файлы можно сохранить в архиве, а также максимальный размер имеющегося файла, который может быть сохранён в архиве, при условии,
# что сохранены файлы максимально возможного числа пользователей.
# В первой строке входного файла находятся два числа: S  — размер свободного места на диске (натуральное число, не превышающее 10 000)
# и N  — количество пользователей (натуральное число, не превышающее 2000).
# В следующих N строках находятся значения объёмов файлов каждого пользователя (все числа натуральные, не превышающие 100),
# каждое в отдельной строке.

# Запишите в ответе два числа: сначала наибольшее число пользователей, чьи файлы могут быть помещены в архив,
# затем максимальный размер имеющегося файла, который может быть сохранён в архиве, при условии,
# что сохранены файлы максимально возможного числа пользователей.
#
m = []
new_m = []
sort_first = []
with open('C:/Users/vngorlachev/Documents/VisualStudioCode/Projects/txt/27886.txt') as file:
    for line in file:
        m.append(line.split())
# Из-за присутствия в файле в первой строке двух значений, получаем список в списке, это надо учитывать при обработке.
# из первой строки файла забираем первое значение - объем свободного пространства диска
freeDiskSpace = int(m[0][0])
# удалим из списка первый вложенный список, полученный из первой строки файла
m.pop(0)
#print(m)
# Перекиним наш список в новый список, ликвидировав вложенность и преобразовав строковые значения в int
for i in m:
    new_m.append(int(i[0]))
# Сортировка обязательно нужна по условию задачи
sort_first = sorted(new_m)

count = 0
i = 0
usedDiskSpace = 0

# Основной цикл и промежуточные результаты выполнения
# выполняется пока свободное место на диске имеется
while freeDiskSpace > usedDiskSpace:
    print(usedDiskSpace, ' + ', sort_first[i], ' = ', usedDiskSpace + sort_first[i])
    # Если свободное место на диске больше, чем уже занятое + размер i-того пользователя
    if freeDiskSpace >= usedDiskSpace + sort_first[i]:
        # займем пространство размером пользователя и посчитаем количество пользователей
        usedDiskSpace = usedDiskSpace + sort_first[i]
        count += 1
    else:
        # Если свободного пространства для добавления i-того пользователя недостаточно,
        print(usedDiskSpace, ' - ', sort_first[i], ' = ', usedDiskSpace - sort_first[i-1])
        # уберем предыдущего пользователя (i-1) из рассчета (так как по условию, нам надо вставить пользователя
        # с максимальным размером файлов) и попробуем впихнуть файлы следующего пользователя в следующей итерации цикла.
        # количество пользователей уменьшим
        usedDiskSpace = usedDiskSpace - sort_first[i-1]
        count -= 1
        # Если даже после удаления файлов предыдущего пользователя файлы следующего пользователя не помещаются, выходим из цикла
        if freeDiskSpace < usedDiskSpace + sort_first[i]:
            break
    i += 1
print(count, sort_first[i])







