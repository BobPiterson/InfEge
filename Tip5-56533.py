# Алгоритм получает на вход натуральное число N и строит по нему новое число R следующим образом:
# 1.  Строится двоичная запись числа N.
# 2.  Если сумма цифр десятичной записи заданного числа нечётна, то в конец двоичной записи дописывается 1, если чётна  — 0.
# 3−4. Пункт 2 повторяется для вновь полученных чисел ещё два раза.
# 5.  Результатом работы алгоритма становится десятичная запись полученного числа R.
#
# Определите количество принадлежащих отрезку [987 654 321; 2 123 456 789] чисел,
# которые могут получиться в результате работы этого алгоритма.
#
# Так как программа ищет решение перебором, работа занимает около 10 минут времени.
#
# Нужно обратить внимание, что после преобразования любого числа, исходное число становится больше примерно в 8 раз
# исходя из этого выберем диапазон значений числа N для полного перебора, например возьмем за начало диапазона число:
# n10 = 987654321 // 8 = 123456790 и подставим его для проверки, видим что результат попадает в диапазон
# так же поступим с концом диапазона, подбирая в меньшую сторону: n10 = 2123456783 // 8 = 265432097
# функция ищет сумму цифр числа
def summa(number):
    sum_tmp = 0
    for i in str(number):
        sum_tmp = sum_tmp + int(i)
    return sum_tmp

count = 0
for n10 in range(123456790, 265432097):
    n2 = bin(n10)[2:]
    for i in [1,2,3]:
        if summa(int(n2, 2)) % 2 != 0:
            n2 = n2 + '1'
        else:
            n2 = n2 + '0'
    if int(n2,2) > 987654321 and int(n2,2) < 2123456789:
        count = count + 1
        # Чтобы наблюдать за процессом, будем выводить на экран каждое милионное число
        if count % 1000000 == 0: print(n10, count)
print(count)
