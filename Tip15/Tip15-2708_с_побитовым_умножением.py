# https://kompege.ru/variant
# Определите, сколько всего существует натуральных чисел R таких, что выражение
# f = (((x & 108 == 0) or (x & 60 == 0)) <= (x & A == 0)) or (x & R == 0), где & означает побитовое умножение.
# тождественно истинно при любом натуральном значении переменной х
# и любом натуральном значении переменной А.
# Суть задачи в том, что какими бы ни были значения А и х, при некоторых (искомых) значениях R значение функции будет ИСТИННО. Эти значения нужно найти.
count = 0
r_set = set()
for r in range(1, 110):
    # Перед интересующим диапазоном погасим флаг. Если за два внутренних цикла он не поднимется, значит диапазон нам подходит.
    flag_x = False
    for A in range(1, 110):
        for x in range(1, 110):
            # Если функция стала ложна хотя бы при одном значении х или А из диапазона (1, 110)
            if not ((((x & 108 == 0) or (x & 60 == 0)) <= (x & A == 0)) or (x & r == 0)):
                # взводим флаг неподходящего диапазона для х и выходим из внутреннего цикла x, дальше этот диапазон не подходит
                flag_x = True
                break
        # Мы должны выйти из цикла А тоже, так как в этом диапазоне наткнулись на одно неподходящее значение
        if flag_x:
                break
    # Если проверили все значения А и х на всем диапазоне и все значения привели функцию к значению ИСТИНА
    if not flag_x:
        count += 1
        r_set.add(r)

print(r_set)
print('Ответ:', count)

